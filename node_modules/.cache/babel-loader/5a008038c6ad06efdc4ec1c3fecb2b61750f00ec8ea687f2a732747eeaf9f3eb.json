{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\n\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const nextNodesStack = [];\n  nextNodesStack.push(startNode);\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.pop();\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n    if (!currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const {\n        col,\n        row\n      } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["dfs","grid","startNode","finishNode","visitedNodesInOrder","nextNodesStack","push","length","currentNode","pop","isWall","isStart","isVisited","col","row","nextNode","previousNode"],"sources":["/Users/buddy/Documents/GitHub/Pathfinding-Simulator/src/algorithms/dfs.js"],"sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA,OAAO,SAASA,GAAG,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAC/C,MAAMC,mBAAmB,GAAG,EAAE;EAC9B,MAAMC,cAAc,GAAG,EAAE;EACzBA,cAAc,CAACC,IAAI,CAACJ,SAAS,CAAC;EAC9B,OAAOG,cAAc,CAACE,MAAM,EAAE;IAC5B,MAAMC,WAAW,GAAGH,cAAc,CAACI,GAAG,EAAE;IAExC,IAAID,WAAW,KAAKL,UAAU,EAAE;MAC9B,OAAOC,mBAAmB;IAC5B;IAEA,IACE,CAACI,WAAW,CAACE,MAAM,KAClBF,WAAW,CAACG,OAAO,IAAI,CAACH,WAAW,CAACI,SAAS,CAAC,EAC/C;MACAJ,WAAW,CAACI,SAAS,GAAG,IAAI;MAC5BR,mBAAmB,CAACE,IAAI,CAACE,WAAW,CAAC;MAErC,MAAM;QAACK,GAAG;QAAEC;MAAG,CAAC,GAAGN,WAAW;MAC9B,IAAIO,QAAQ;MACZ,IAAID,GAAG,GAAG,CAAC,EAAE;QACXC,QAAQ,GAAGd,IAAI,CAACa,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC;QAC7B,IAAI,CAACE,QAAQ,CAACH,SAAS,EAAE;UACvBG,QAAQ,CAACC,YAAY,GAAGR,WAAW;UACnCH,cAAc,CAACC,IAAI,CAACS,QAAQ,CAAC;QAC/B;MACF;MACA,IAAID,GAAG,GAAGb,IAAI,CAACM,MAAM,GAAG,CAAC,EAAE;QACzBQ,QAAQ,GAAGd,IAAI,CAACa,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC;QAC7B,IAAI,CAACE,QAAQ,CAACH,SAAS,EAAE;UACvBG,QAAQ,CAACC,YAAY,GAAGR,WAAW;UACnCH,cAAc,CAACC,IAAI,CAACS,QAAQ,CAAC;QAC/B;MACF;MACA,IAAIF,GAAG,GAAG,CAAC,EAAE;QACXE,QAAQ,GAAGd,IAAI,CAACa,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC;QAC7B,IAAI,CAACE,QAAQ,CAACH,SAAS,EAAE;UACvBG,QAAQ,CAACC,YAAY,GAAGR,WAAW;UACnCH,cAAc,CAACC,IAAI,CAACS,QAAQ,CAAC;QAC/B;MACF;MACA,IAAIF,GAAG,GAAGZ,IAAI,CAAC,CAAC,CAAC,CAACM,MAAM,GAAG,CAAC,EAAE;QAC5BQ,QAAQ,GAAGd,IAAI,CAACa,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC;QAC7B,IAAI,CAACE,QAAQ,CAACH,SAAS,EAAE;UACvBG,QAAQ,CAACC,YAAY,GAAGR,WAAW;UACnCH,cAAc,CAACC,IAAI,CAACS,QAAQ,CAAC;QAC/B;MACF;IACF;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}