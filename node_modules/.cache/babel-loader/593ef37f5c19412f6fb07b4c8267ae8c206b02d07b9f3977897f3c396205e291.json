{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/buddy/Documents/GitHub/Pathfinding-Simulator/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);// Q: different from using grid or slice of grid???\nwhile(unvisitedNodes.length){sortNodesByDistance(unvisitedNodes);var closestNode=unvisitedNodes.shift();// If we encounter a wall, we skip it.\nif(!closestNode.isWall){// If the closest node is at a distance of infinity,\n// we must be trapped and should stop.\nif(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid);}}}function getAllNodes(grid){var nodes=[];var _iterator=_createForOfIteratorHelper(grid),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var row=_step.value;var _iterator2=_createForOfIteratorHelper(row),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var node=_step2.value;nodes.push(node);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return nodes;}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){return nodeA.distance-nodeB.distance;});}function updateUnvisitedNeighbors(node,grid){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator3=_createForOfIteratorHelper(unvisitedNeighbors),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var neighbor=_step3.value;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}","map":{"version":3,"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","nodes","row","node","sort","nodeA","nodeB","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","filter"],"sources":["/Users/buddy/Documents/GitHub/Pathfinding-Simulator/src/algorithms/dijkstra.js"],"sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n"],"mappings":"iKAAA;AACA;AACA;AAEA,MAAO,SAASA,SAAQ,CAACC,IAAI,CAAEC,SAAS,CAAEC,UAAU,CAAE,CACpD,GAAMC,oBAAmB,CAAG,EAAE,CAC9BF,SAAS,CAACG,QAAQ,CAAG,CAAC,CACtB,GAAMC,eAAc,CAAGC,WAAW,CAACN,IAAI,CAAC,CAAE;AAE1C,MAAOK,cAAc,CAACE,MAAM,CAAE,CAC5BC,mBAAmB,CAACH,cAAc,CAAC,CACnC,GAAMI,YAAW,CAAGJ,cAAc,CAACK,KAAK,EAAE,CAC1C;AACA,GAAI,CAACD,WAAW,CAACE,MAAM,CAAE,CACvB;AACA;AACA,GAAIF,WAAW,CAACL,QAAQ,GAAKQ,QAAQ,CAAE,MAAOT,oBAAmB,CACjEM,WAAW,CAACI,SAAS,CAAG,IAAI,CAC5BV,mBAAmB,CAACW,IAAI,CAACL,WAAW,CAAC,CACrC,GAAIA,WAAW,GAAKP,UAAU,CAAE,MAAOC,oBAAmB,CAC1DY,wBAAwB,CAACN,WAAW,CAAET,IAAI,CAAC,CAC7C,CACF,CACF,CAEA,QAASM,YAAW,CAACN,IAAI,CAAE,CACzB,GAAMgB,MAAK,CAAG,EAAE,CAAC,yCACChB,IAAI,YAAtB,+CAAwB,IAAbiB,IAAG,uDACOA,GAAG,aAAtB,kDAAwB,IAAbC,KAAI,cACbF,KAAK,CAACF,IAAI,CAACI,IAAI,CAAC,CAClB,CAAC,uDACH,CAAC,qDACD,MAAOF,MAAK,CACd,CAEA,QAASR,oBAAmB,CAACH,cAAc,CAAE,CAC3CA,cAAc,CAACc,IAAI,CAAC,SAACC,KAAK,CAAEC,KAAK,QAAKD,MAAK,CAAChB,QAAQ,CAAGiB,KAAK,CAACjB,QAAQ,GAAC,CACxE,CAEA,QAASW,yBAAwB,CAACG,IAAI,CAAElB,IAAI,CAAE,CAC5C,GAAMsB,mBAAkB,CAAGC,qBAAqB,CAACL,IAAI,CAAElB,IAAI,CAAC,CAAC,0CACtCsB,kBAAkB,aAAzC,kDAA2C,IAAhCE,SAAQ,cACjBA,QAAQ,CAACpB,QAAQ,CAAGc,IAAI,CAACd,QAAQ,CAAG,CAAC,CACrCoB,QAAQ,CAACC,YAAY,CAAGP,IAAI,CAC9B,CAAC,uDACH,CAEA,QAASK,sBAAqB,CAACL,IAAI,CAAElB,IAAI,CAAE,CACzC,GAAM0B,UAAS,CAAG,EAAE,CACpB,GAAOC,IAAG,CAAST,IAAI,CAAhBS,GAAG,CAAEV,GAAG,CAAIC,IAAI,CAAXD,GAAG,CACf,GAAIA,GAAG,CAAG,CAAC,CAAES,SAAS,CAACZ,IAAI,CAACd,IAAI,CAACiB,GAAG,CAAG,CAAC,CAAC,CAACU,GAAG,CAAC,CAAC,CAC/C,GAAIV,GAAG,CAAGjB,IAAI,CAACO,MAAM,CAAG,CAAC,CAAEmB,SAAS,CAACZ,IAAI,CAACd,IAAI,CAACiB,GAAG,CAAG,CAAC,CAAC,CAACU,GAAG,CAAC,CAAC,CAC7D,GAAIA,GAAG,CAAG,CAAC,CAAED,SAAS,CAACZ,IAAI,CAACd,IAAI,CAACiB,GAAG,CAAC,CAACU,GAAG,CAAG,CAAC,CAAC,CAAC,CAC/C,GAAIA,GAAG,CAAG3B,IAAI,CAAC,CAAC,CAAC,CAACO,MAAM,CAAG,CAAC,CAAEmB,SAAS,CAACZ,IAAI,CAACd,IAAI,CAACiB,GAAG,CAAC,CAACU,GAAG,CAAG,CAAC,CAAC,CAAC,CAChE,MAAOD,UAAS,CAACE,MAAM,CAAC,SAAAJ,QAAQ,QAAI,CAACA,QAAQ,CAACX,SAAS,GAAC,CAC1D"},"metadata":{},"sourceType":"module","externalDependencies":[]}